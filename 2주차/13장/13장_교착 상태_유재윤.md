

# 교착 상태란?

<aside>
💡 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상을 의미합니다.

</aside>

<br>
<br>

<details><summary><h3>식사하는 철학자 문제</h3></summary>

<img width="359" alt="스크린샷 2023-08-31 오후 8 17 20" src="https://github.com/yoojaeyoonGit/computer-architecture-and-operating-system/assets/110767749/2aeb2167-77c1-44f5-9290-078c5c64e2bf">

계속 생각을 하다 왼쪽 포크가 사용 가능하면 집어든다

계속 생각을 하다 오른쪽 포크가 사용 가능하면 집어든다

왼쪽과 오른쪽 포크를 모두 집어들면 정해진 시간동안 식사를 한다

식사 시간이 끝나면 오른쪽 포크를 내려놓는다.

오른쪽 포크를 내려놓은 뒤 왼쪽 포크를 내려놓는다.

다시 (1)번 부터 반복한다.

한 두명의 철학자가 식사할 때는 문제 없지만 동시에 모든 철학자가 포크를 집어들면  모두 오른쪽 포크를 집을 수 없다. 이는 모든 철학자는 다른 철학자가 포크를 내려놓을 때까지 기다린다는 의미이다.

이렇게 일어나지 않을 사건을 기다리며 진행이 멈춰 버리는 현상을 **교착상태**라고 한다.

> 식사하는 철학자 문제에서 철학자는 
프로세스 혹은 스레드, 포크와 생각하는 행위는 자원에 빗댈 수 있음
> 

게임 프로세스는 자원 A를 점유한 채 웹 브라우저 프로세스가 점유하고 있는 자원 B의 사용이 끝나길 기다리고, 웹 브라우저 프로세스는 자원 B를 점유한 채 게임 프로세스의 자원 A가 사용이 끝나길 기다리는 상황

이 경우 게임과 웹 브라우저 프로세스는 상대방이 가진 자원을 기다리기만 하다가 결국 실행한번 못하는 상황이 벌어짐. 이를 교착상태라고 한다.

![deadlock](https://github.com/yoojaeyoonGit/computer-architecture-and-operating-system/assets/110767749/6bd71610-4c6b-4a5f-b36a-69168c6bb76f)

교착 상태는 다양한 상황에서 발생한다.

교착 상태를 해결하기 위해는 발생했을 때의 상황을 정확히 표현해 보고, 교착 상태가 일어나는 근본적인 이유대 대해 알아야한다.

</details>


## 자원 할당 그래프

교착 상태는 자원 할당 그래프를 통해 단순하게 표현될 수 있다.

자원 할당 그래프는 어떤 프로세스가 어떤 자원을 사용하고, 어떤 자원을 기다리는지 표현하는 간단한 그래프

<br>

**자원 할당 그래프 규칙**

1. 프로세스는 원으로, 자원의 종류는 사각형으로 표현한다.
2. 사용할 수 있는 자원의 개수는 자원 사각형 내에 점으로 표현한다.
3. 프로세스가 어떤 자원을 할당받아 사용 중이라면 자원에서 프로세스를 통해 화살표를 표시한다.
4. 프로세스가 어떤 자원을 기다리고 있다면 프로세스에서 자원으로 화살표를 표시한다

![resource-allocation-graph](https://github.com/yoojaeyoonGit/computer-architecture-and-operating-system/assets/110767749/7c0f3c8b-c694-4383-b0e3-43cd5dd635fa)

<br>

### 식사하는 철학자 문제 자원 할당 그래프

<img width="289" alt="philosophy" src="https://github.com/yoojaeyoonGit/computer-architecture-and-operating-system/assets/110767749/876020f1-b76d-4707-a1d2-15fa15ab09f2">


교착 상태가 발생한 상황은 자원 할당 그래프가 원의 형태를 띄고 있다.

<br>

## 교착 상태 발생 조건

1. 상호 배제 
    - 교착 상태가 발생한 근본적인 원인은 해당 자원을 한 번에 하나의 프로세스만 이용 가능했기 때문이다.
    한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없을때, **상호배제 상황에서 교착 상태가 발생한다.**
2. 점유와 대기 
    - 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다리는 상태
3. 비선점
    - 비선점 자원은 그 자원을 이용하는 프로세스의 작업이 끝나야만 이용할 수 있다.
    어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못했기 떄문에 교착상태가 발생한다.
4. 원형 대기
    - 프로세스들과 프로세스가 요청 및 할당받은 자원이 원의 형태를 이루었기 때문에 발생

<br>
<br>

# 교착 상태 예방

<aside>
💡 교착 상태를 예방하는 방법은 교착 상태 발생 필요조건 
네 가지 중 하나를 충족하지 못하게 하는 방법과 같다.

</aside>

<br>

### 자원의 상호 배제 해결

자원의 상호 배제를 해결한다는 의미는 모든 자원을 공유 가능하게 만든다는 말과 같다.

그러나 이 방식 대로라면 교착 상태는 없앨 수 있으나, 모든 자원의 상호 배제를 없애기는 어렵다.

<br>

### 점유와 대기 해결

운영체제는 특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지 않는 방식으로 배분한다.

이 방식 또한 해결할 수 있지만 단점이 있다.

1. **자원의 활용률이 낮아진다.**
2. **기아현상을 야기할 우려가 있다.**

<br>

### 원형대기 조건 해결

모든 자원에 번호를 붙이고, 오름차순으로 자원을 할당하면 원형대기는 발생하지 않는다.

이 방법 또한 실제 사용하기엔 단점이 있다.

<br>

### 교착 상태 회피

교착 상태가 발생하지 않을 정도로만 자원을 할당하는 방식

프로세스들에 할당할 수 있는 자원이 한정된 상황에서 모든 프로세스들이 한 번에 많은 자원을 요구하면 교착 상태 발생 위험이 증가한다.
프로세스들에 배분할 수 있는 자원의 양을 고려하여 교착 상태가 발생하지 않을 정도의 양만큼만 자원을 배분하는 방법이 교착 상태 회피이다.

<br>

**안전상태** <br>

교착 상태가 발생하지 않고 모든 프로세스가 정상적으로 자원을 할당 받고 종료 될 수 있는 상태

<br>

**불안전 상태** <br>
교착 상태가 발생할 수도 있는 상태

<br>

**안전 순서열**
교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서를 의미한다.

안전 상태  <br>
<img width="287" alt="safe_sequence_safe" src="https://github.com/yoojaeyoonGit/computer-architecture-and-operating-system/assets/110767749/74c927ef-2781-4497-ab43-229c7bb07aa0">

안전 순서열  p2 → p1 → p3 대로 자원을 배분하면 교착 상태 없이 올바르게 작업을 마칠 수 있다.

불안전 상태 (교착 상태 발생) <br>
<img width="287" alt="safe_sequence_unsafe" src="https://github.com/yoojaeyoonGit/computer-architecture-and-operating-system/assets/110767749/f5d43561-7d6b-4aea-a568-652c6aa29be1">

p2 → p1 → p3 대로 자원을 배분하면 불완전 상태로 교착 상태가 발생한다

운영체제가 교착 상태를 회피하기 위해서는 시스템 상태가 안전 상태에서 안전상태로 움직이는 경우에만 자원을 할당해야 한다.

교착 상태 회피 방식은 항시 안전 상태를 유지하도록 자원을 할당하는 방식이다.

<br>
<br>

### 교착 상태 검출 후 회복

교착 상태 발생을 인정하고 사후 조치 방법
<br>
1. 선점을 통한 회복 <br>
교착 상태가 해결 될때 까지 한 프로세스 씩 자원을 몰아주는 방식 <br>
교착 상태가 해결될 때까지 다른 프로세스로부터 자원을 강제로 빼앗고 한 프로세스에 할당하는 방식
<br>

2. 프로세스 강제 종료를 통한 회복
   프로세스 강제 종료를 통한 회복은 가장 단순하면서 확실한 방식
      <details><summary><strong>교착 상태에 놓인 프로세스를 모두 강제종료</strong></summary>
        &nbsp;&nbsp;&nbsp; - 교착 상태를 해결하는 확실한 방법이지만 그만큼 많은 프로세스들이 작업 내역을 잃을 수 있다.
      </details>
      <br>
      <details><summary><strong>교착 상태가 없어질 때까지 한 프로세스 씩 강제 종료</strong></summary>
        &nbsp;&nbsp;&nbsp; - 작업 내역을 잃는 프로세스를 최대한 줄일 수 있지만 교착 상태가 없어졌는지 여부를 확인하는 과정에서 오버헤드를 야기한다.
      </details> 

<br>
<br>


### 타조 알고리즘 (Ostrich Algorithm)

![ostrich_algorithm](https://github.com/yoojaeyoonGit/computer-architecture-and-operating-system/assets/110767749/2c1a3073-e85e-416d-b917-d67eeea582b8)

교착 상태를 아예 무시하는 방법

드물게 발생하는 잠재적 문제를 무시로 대처하는 방식이다.
